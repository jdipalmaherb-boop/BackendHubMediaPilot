import OpenAI from 'openai';
import { z } from 'zod';
import { logger } from '../../utils/logger.js';
import { LearningDataService } from '../services/LearningDataService.js';

// Sabri Suby Direct Response Formula: Pain → Solution → Clear Offer → Urgency
interface DirectResponseFormula {
  pain: string;
  solution: string;
  offer: string;
  urgency: string;
  socialProof?: string;
  guarantee?: string;
}

interface AdCopyVariation {
  headline: string;
  primaryText: string;
  cta: string;
  formula: DirectResponseFormula;
  confidence: number;
  targetAudience: string;
  painPoints: string[];
  benefits: string[];
  urgencyFactors: string[];
}

interface CopyGenerationRequest {
  product: string;
  targetAudience: string;
  painPoints: string[];
  benefits: string[];
  platform: 'META' | 'GOOGLE' | 'TIKTOK' | 'LINKEDIN' | 'TWITTER';
  objective: 'AWARENESS' | 'TRAFFIC' | 'ENGAGEMENT' | 'LEADS' | 'SALES' | 'APP_INSTALLS' | 'VIDEO_VIEWS';
  brandVoice?: string;
  previousPerformance?: any[];
  competitorAnalysis?: any[];
}

export class AdCopyGenerator {
  private openai: OpenAI;
  private learningService: LearningDataService;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.learningService = new LearningDataService();
  }

  /**
   * Generate multiple ad copy variations using AI
   * Follows Sabri Suby direct-response formula with platform-specific optimization
   */
  async generateAdCopy(request: CopyGenerationRequest): Promise<AdCopyVariation[]> {
    try {
      logger.info('Generating ad copy variations', { 
        product: request.product, 
        platform: request.platform,
        objective: request.objective 
      });

      // Get historical performance data for learning
      const historicalData = await this.learningService.getCopyPerformanceData({
        platform: request.platform,
        objective: request.objective,
        targetAudience: request.targetAudience
      });

      // Generate multiple variations
      const variations: AdCopyVariation[] = [];
      
      // Generate 5 different variations with different approaches
      for (let i = 0; i < 5; i++) {
        const variation = await this.generateSingleVariation(request, i, historicalData);
        variations.push(variation);
      }

      // Sort by confidence score
      variations.sort((a, b) => b.confidence - a.confidence);

      logger.info('Generated ad copy variations', { 
        count: variations.length,
        topConfidence: variations[0]?.confidence 
      });

      return variations;

    } catch (error) {
      logger.error('Failed to generate ad copy', { error: error.message });
      throw new Error(`Ad copy generation failed: ${error.message}`);
    }
  }

  /**
   * Generate a single ad copy variation
   */
  private async generateSingleVariation(
    request: CopyGenerationRequest, 
    variationIndex: number,
    historicalData: any[]
  ): Promise<AdCopyVariation> {
    const approach = this.getApproachByIndex(variationIndex);
    
    const prompt = this.buildCopyGenerationPrompt(request, approach, historicalData);
    
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: `You are a world-class direct-response copywriter specializing in ${request.platform} ads. 
          You follow the Sabri Suby formula: Pain → Solution → Clear Offer → Urgency.
          Generate high-converting ad copy that drives immediate action.`
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7 + (variationIndex * 0.1), // Increase creativity with each variation
      max_tokens: 1000
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content generated by OpenAI');
    }

    return this.parseGeneratedCopy(content, request);
  }

  /**
   * Build the prompt for copy generation
   */
  private buildCopyGenerationPrompt(
    request: CopyGenerationRequest, 
    approach: string,
    historicalData: any[]
  ): string {
    const historicalInsights = historicalData.length > 0 
      ? `\n\nHistorical Performance Insights:\n${this.formatHistoricalData(historicalData)}`
      : '';

    return `
Generate a high-converting ad copy for ${request.platform} following the ${approach} approach.

Product: ${request.product}
Target Audience: ${request.targetAudience}
Pain Points: ${request.painPoints.join(', ')}
Benefits: ${request.benefits.join(', ')}
Platform: ${request.platform}
Objective: ${request.objective}
Brand Voice: ${request.brandVoice || 'Professional and trustworthy'}

${historicalInsights}

Please generate the ad copy in the following JSON format:
{
  "headline": "Compelling headline (max 40 characters for most platforms)",
  "primaryText": "Main ad text that follows the pain-solution-offer-urgency formula",
  "cta": "Clear call-to-action button text",
  "formula": {
    "pain": "The specific pain point being addressed",
    "solution": "How the product solves this pain",
    "offer": "The clear, specific offer",
    "urgency": "Why they need to act now",
    "socialProof": "Social proof element (optional)",
    "guarantee": "Risk reversal element (optional)"
  },
  "confidence": 0.85,
  "targetAudience": "Refined audience description",
  "painPoints": ["Specific pain points addressed"],
  "benefits": ["Key benefits highlighted"],
  "urgencyFactors": ["Elements creating urgency"]
}

Guidelines:
- Use emotional triggers and power words
- Create urgency without being pushy
- Include specific numbers and results when possible
- Make the offer irresistible
- Use platform-appropriate language and length
- Follow the direct-response formula religiously
- Ensure the CTA is action-oriented and clear
    `.trim();
  }

  /**
   * Parse the generated copy from OpenAI response
   */
  private parseGeneratedCopy(content: string, request: CopyGenerationRequest): AdCopyVariation {
    try {
      // Extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No JSON found in response');
      }

      const parsed = JSON.parse(jsonMatch[0]);
      
      // Validate the structure
      const schema = z.object({
        headline: z.string(),
        primaryText: z.string(),
        cta: z.string(),
        formula: z.object({
          pain: z.string(),
          solution: z.string(),
          offer: z.string(),
          urgency: z.string(),
          socialProof: z.string().optional(),
          guarantee: z.string().optional()
        }),
        confidence: z.number().min(0).max(1),
        targetAudience: z.string(),
        painPoints: z.array(z.string()),
        benefits: z.array(z.string()),
        urgencyFactors: z.array(z.string())
      });

      return schema.parse(parsed);

    } catch (error) {
      logger.error('Failed to parse generated copy', { error: error.message, content });
      
      // Return a fallback variation
      return this.createFallbackVariation(request);
    }
  }

  /**
   * Create a fallback variation if parsing fails
   */
  private createFallbackVariation(request: CopyGenerationRequest): AdCopyVariation {
    return {
      headline: `Transform Your ${request.product} Results Today`,
      primaryText: `Struggling with ${request.painPoints[0]}? Our proven solution has helped thousands achieve ${request.benefits[0]}. Get instant access to our step-by-step system and see results in 30 days or less. Limited time offer - act now!`,
      cta: 'Get Started Now',
      formula: {
        pain: request.painPoints[0] || 'Your current challenges',
        solution: `Our ${request.product} solution`,
        offer: 'Step-by-step system with guaranteed results',
        urgency: 'Limited time offer',
        guarantee: '30-day money-back guarantee'
      },
      confidence: 0.6,
      targetAudience: request.targetAudience,
      painPoints: request.painPoints,
      benefits: request.benefits,
      urgencyFactors: ['Limited time', 'Exclusive offer']
    };
  }

  /**
   * Get different approaches for variation generation
   */
  private getApproachByIndex(index: number): string {
    const approaches = [
      'Pain-focused direct response',
      'Benefit-driven emotional appeal',
      'Social proof and authority',
      'Urgency and scarcity',
      'Problem-solution narrative'
    ];
    return approaches[index % approaches.length];
  }

  /**
   * Format historical data for prompt context
   */
  private formatHistoricalData(data: any[]): string {
    return data.slice(0, 5).map(item => 
      `- ${item.headline}: CTR ${item.ctr}%, CPC $${item.cpc}, Conversions ${item.conversions}`
    ).join('\n');
  }

  /**
   * Analyze copy performance and learn from results
   */
  async analyzeCopyPerformance(
    copyId: string, 
    performance: any
  ): Promise<void> {
    try {
      await this.learningService.recordCopyPerformance({
        copyId,
        performance,
        timestamp: new Date()
      });

      logger.info('Recorded copy performance for learning', { copyId });
    } catch (error) {
      logger.error('Failed to analyze copy performance', { error: error.message });
    }
  }

  /**
   * Get copy recommendations based on performance data
   */
  async getCopyRecommendations(
    platform: string,
    objective: string,
    targetAudience: string
  ): Promise<string[]> {
    try {
      const insights = await this.learningService.getCopyInsights({
        platform,
        objective,
        targetAudience
      });

      return insights.map(insight => insight.recommendation);
    } catch (error) {
      logger.error('Failed to get copy recommendations', { error: error.message });
      return [];
    }
  }

  /**
   * Test copy variations using A/B testing
   */
  async createABTest(
    campaignId: string,
    variations: AdCopyVariation[],
    testConfig: any
  ): Promise<string> {
    try {
      // Implementation for A/B testing setup
      logger.info('Creating A/B test for copy variations', { 
        campaignId, 
        variationCount: variations.length 
      });

      // This would integrate with the A/B testing system
      return `ab_test_${Date.now()}`;
    } catch (error) {
      logger.error('Failed to create A/B test', { error: error.message });
      throw error;
    }
  }
}



